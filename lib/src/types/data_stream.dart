import 'dart:async';
import 'dart:io' show File;

import '../data_stream/errors.dart';
import '../data_stream/stream_reader.dart';
import '../e2ee/options.dart';
import '../proto/livekit_models.pb.dart' as lk_models;
import '../proto/livekit_models.pb.dart' show Encryption_Type, DataStream_Chunk;

const kStreamChunkSize = 15_000;

class SendTextOptions {
  String? topic;

  List<String> destinationIdentities = [];
  List<File> attachments = [];

  Function(double)? onProgress;

  /// user defined attributes map that can carry additional info
  Map<String, String> attributes;

  SendTextOptions({
    this.topic,
    this.destinationIdentities = const [],
    this.attachments = const [],
    this.onProgress,
    this.attributes = const {},
  });
}

class SendFileOptions {
  String? mimeType;
  String? topic;
  List<String> destinationIdentities = [];
  Encryption_Type? encryptionType;

  Function(double)? onProgress;

  SendFileOptions({
    this.mimeType,
    this.topic,
    this.destinationIdentities = const [],
    this.encryptionType = Encryption_Type.NONE,
    this.onProgress,
  });
}

class StreamTextOptions {
  String? topic;
  List<String> destinationIdentities = [];
  String? streamId;
  int? version;
  List<String> attachedStreamIds = [];
  String? replyToStreamId;
  int? totalSize;

  /// 'create' | 'update' | 'delete' | 'reaction'
  TextStreamOperationType? type;

  /// true if the text has been generated by an agent from a participant's audio transcription
  bool generated;

  /// user defined attributes map that can carry additional info
  Map<String, String> attributes;

  StreamTextOptions({
    this.topic,
    this.destinationIdentities = const [],
    this.streamId,
    this.version,
    this.attachedStreamIds = const [],
    this.replyToStreamId,
    this.totalSize,
    this.type,
    this.generated = false,
    this.attributes = const {},
  });

  @override
  String toString() => '${runtimeType}'
      '(topic: $topic, destinationIdentities: $destinationIdentities, '
      'streamId: $streamId, totalSize: $totalSize, type: $type, version: $version, '
      'replyToStreamId: $replyToStreamId, attachedStreamIds: $attachedStreamIds)';
}

class StreamBytesOptions {
  String? name;
  String? mimeType;
  String? topic;
  List<String> destinationIdentities;
  Map<String, String> attributes;
  String? streamId;
  int? totalSize;
  Encryption_Type? encryptionType;

  StreamBytesOptions({
    this.name,
    this.mimeType,
    this.topic,
    this.destinationIdentities = const [],
    this.attributes = const {},
    this.streamId,
    this.totalSize,
    this.encryptionType = Encryption_Type.NONE,
  });

  @override
  String toString() => '${runtimeType}'
      '(name: $name, mimeType: $mimeType, topic: $topic, destinationIdentities: $destinationIdentities, '
      'attributes: $attributes, streamId: $streamId, totalSize: $totalSize, encryptionType: $encryptionType)';
}

class ChatMessage {
  String id;
  int timestamp;
  String message;
  int? editTimestamp;
  List<File> attachedFiles;
  ChatMessage({
    required this.id,
    required this.timestamp,
    required this.message,
    this.editTimestamp,
    this.attachedFiles = const [],
  });
}

class BaseStreamInfo {
  String id;
  String mimeType;
  String topic;
  int timestamp;
  int size;
  Map<String, String> attributes;
  String sendingParticipantIdentity;
  EncryptionType encryptionType;
  BaseStreamInfo({
    required this.id,
    required this.mimeType,
    required this.topic,
    required this.timestamp,
    required this.size,
    this.attributes = const {},
    this.sendingParticipantIdentity = '',
    this.encryptionType = EncryptionType.kNone,
  });
}

class DataStreamController<T extends DataStream_Chunk> {
  late BaseStreamInfo info;
  late StreamController<T> streamController;
  late num startTime;
  num? endTime;
  DataStreamController({
    required this.info,
    required this.streamController,
    required this.startTime,
    this.endTime,
  });

  Future<void> close() => streamController.close();

  void write(T chunk) => streamController.add(chunk);

  void error(DataStreamError error) => streamController.addError(error);
}

class ByteStreamInfo extends BaseStreamInfo {
  String name;
  ByteStreamInfo({
    required this.name,
    required String id,
    required String mimeType,
    required String topic,
    required int timestamp,
    required int size,
    Map<String, String> attributes = const {},
    required String sendingParticipantIdentity,
    EncryptionType encryptionType = EncryptionType.kNone,
  }) : super(
          id: id,
          mimeType: mimeType,
          topic: topic,
          timestamp: timestamp,
          size: size,
          attributes: attributes,
          sendingParticipantIdentity: sendingParticipantIdentity,
          encryptionType: encryptionType,
        );

  @override
  String toString() => '${runtimeType}'
      '(name: $name, id: $id, mimeType: $mimeType, topic: $topic, '
      'timestamp: $timestamp, size: $size, attributes: $attributes)';
}

/// Operation types for text streams
enum TextStreamOperationType {
  create,
  update,
  delete,
  reaction;

  static TextStreamOperationType? fromPBType(lk_models.DataStream_OperationType? type) {
    if (type == null) return TextStreamOperationType.create;
    switch (type) {
      case lk_models.DataStream_OperationType.CREATE:
        return TextStreamOperationType.create;
      case lk_models.DataStream_OperationType.UPDATE:
        return TextStreamOperationType.update;
      case lk_models.DataStream_OperationType.DELETE:
        return TextStreamOperationType.delete;
      case lk_models.DataStream_OperationType.REACTION:
        return TextStreamOperationType.reaction;
      default:
        return null;
    }
  }

  lk_models.DataStream_OperationType toPBType() {
    switch (this) {
      case TextStreamOperationType.create:
        return lk_models.DataStream_OperationType.CREATE;
      case TextStreamOperationType.update:
        return lk_models.DataStream_OperationType.UPDATE;
      case TextStreamOperationType.delete:
        return lk_models.DataStream_OperationType.DELETE;
      case TextStreamOperationType.reaction:
        return lk_models.DataStream_OperationType.REACTION;
    }
  }
}

class TextStreamInfo extends BaseStreamInfo {
  /// The stream ID this message is replying to, if any
  final String? replyToStreamId;

  /// List of stream IDs that are attached to this stream
  final List<String> attachedStreamIds;

  /// Version of the stream
  final int? version;

  /// Whether this text was generated by an agent
  final bool generated;

  /// Operation type for the stream
  final TextStreamOperationType? operationType;

  TextStreamInfo({
    required String id,
    required String mimeType,
    required String topic,
    required int timestamp,
    required int size,
    Map<String, String> attributes = const {},
    this.replyToStreamId,
    this.attachedStreamIds = const [],
    this.version,
    this.generated = false,
    this.operationType,
    required String sendingParticipantIdentity,
    EncryptionType encryptionType = EncryptionType.kNone,
  }) : super(
          id: id,
          mimeType: mimeType,
          topic: topic,
          timestamp: timestamp,
          size: size,
          attributes: attributes,
          encryptionType: encryptionType,
          sendingParticipantIdentity: sendingParticipantIdentity,
        );

  @override
  String toString() => '${runtimeType}'
      '(id: $id, mimeType: $mimeType, topic: $topic, '
      'timestamp: $timestamp, size: $size, attributes: $attributes)';
}

abstract class StreamWriter<T> {
  Future<void> close();

  Future<void> write(T chunk);
}

typedef ByteStreamHandler = void Function(ByteStreamReader reader, String participantIdentity);

typedef TextStreamHandler = Function(TextStreamReader reader, String participantIdentity);
