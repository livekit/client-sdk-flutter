import 'dart:async';
import 'dart:io' show File;

import '../data_stream/stream_reader.dart';
import '../proto/livekit_models.pb.dart' as lk_models;
import '../proto/livekit_models.pb.dart' show Encryption_Type, DataStream_Chunk;

const kStreamChunkSize = 15_000;

class SendTextOptions {
  String? topic;

  List<String> destinationIdentities = [];
  List<File> attachments = [];

  Function(double)? onProgress;

  /// user defined attributes map that can carry additional info
  Map<String, String> attributes;

  SendTextOptions({
    this.topic,
    this.destinationIdentities = const [],
    this.attachments = const [],
    this.onProgress,
    this.attributes = const {},
  });
}

class SendFileOptions {
  String? mimeType;
  String? topic;
  List<String> destinationIdentities = [];
  Encryption_Type? encryptionType;

  Function(double)? onProgress;

  SendFileOptions({
    this.mimeType,
    this.topic,
    this.destinationIdentities = const [],
    this.encryptionType = Encryption_Type.NONE,
    this.onProgress,
  });
}

class StreamTextOptions {
  String? topic;
  List<String> destinationIdentities = [];
  String? streamId;
  int? version;
  List<String> attachedStreamIds = [];
  String? replyToStreamId;
  int? totalSize;

  /// 'create' | 'update' | 'delete' | 'reaction'
  TextStreamOperationType? type;

  /// true if the text has been generated by an agent from a participant's audio transcription
  bool generated;

  /// user defined attributes map that can carry additional info
  Map<String, String> attributes;

  StreamTextOptions({
    this.topic,
    this.destinationIdentities = const [],
    this.streamId,
    this.version,
    this.attachedStreamIds = const [],
    this.replyToStreamId,
    this.totalSize,
    this.type,
    this.generated = false,
    this.attributes = const {},
  });
}

class StreamBytesOptions {
  String? name;
  String? mimeType;
  String? topic;
  List<String> destinationIdentities;
  Map<String, String> attributes;
  String? streamId;
  int? totalSize;
  Encryption_Type? encryptionType;
  StreamBytesOptions({
    this.name,
    this.mimeType,
    this.topic,
    this.destinationIdentities = const [],
    this.attributes = const {},
    this.streamId,
    this.totalSize,
    this.encryptionType = Encryption_Type.NONE,
  });
}

class ChatMessage {
  String id;
  int timestamp;
  String message;
  int? editTimestamp;
  List<File> attachedFiles;
  ChatMessage({
    required this.id,
    required this.timestamp,
    required this.message,
    this.editTimestamp,
    this.attachedFiles = const [],
  });
}

class BaseStreamInfo {
  String id;
  String mimeType;
  String topic;
  int timestamp;
  int size;
  Map<String, String> attributes;
  BaseStreamInfo({
    required this.id,
    required this.mimeType,
    required this.topic,
    required this.timestamp,
    required this.size,
    this.attributes = const {},
  });
}

class DataStreamController<T extends DataStream_Chunk> {
  late BaseStreamInfo info;
  late StreamController<T> streamController;
  late num startTime;
  num? endTime;
  DataStreamController({
    required this.info,
    required this.streamController,
    required this.startTime,
    this.endTime,
  });

  Future<void> close() => streamController.close();

  void write(T chunk) => streamController.add(chunk);
}

class ByteStreamInfo extends BaseStreamInfo {
  String name;
  ByteStreamInfo({
    required this.name,
    required String id,
    required String mimeType,
    required String topic,
    required int timestamp,
    required int size,
    Map<String, String> attributes = const {},
  }) : super(
          id: id,
          mimeType: mimeType,
          topic: topic,
          timestamp: timestamp,
          size: size,
          attributes: attributes,
        );
}

/// Operation types for text streams
enum TextStreamOperationType {
  create,
  update,
  delete,
  reaction;

  static TextStreamOperationType? fromPBType(lk_models.DataStream_OperationType? type) {
    if (type == null) return TextStreamOperationType.create;
    switch (type) {
      case lk_models.DataStream_OperationType.CREATE:
        return TextStreamOperationType.create;
      case lk_models.DataStream_OperationType.UPDATE:
        return TextStreamOperationType.update;
      case lk_models.DataStream_OperationType.DELETE:
        return TextStreamOperationType.delete;
      case lk_models.DataStream_OperationType.REACTION:
        return TextStreamOperationType.reaction;
      default:
        return null;
    }
  }

  lk_models.DataStream_OperationType toPBType() {
    switch (this) {
      case TextStreamOperationType.create:
        return lk_models.DataStream_OperationType.CREATE;
      case TextStreamOperationType.update:
        return lk_models.DataStream_OperationType.UPDATE;
      case TextStreamOperationType.delete:
        return lk_models.DataStream_OperationType.DELETE;
      case TextStreamOperationType.reaction:
        return lk_models.DataStream_OperationType.REACTION;
    }
  }
}

class TextStreamInfo extends BaseStreamInfo {
  /// The stream ID this message is replying to, if any
  final String? replyToStreamId;

  /// List of stream IDs that are attached to this stream
  final List<String> attachedStreamIds;

  /// Version of the stream
  final int? version;

  /// Whether this text was generated by an agent
  final bool generated;

  /// Operation type for the stream
  final TextStreamOperationType? operationType;

  TextStreamInfo({
    required String id,
    required String mimeType,
    required String topic,
    required int timestamp,
    required int size,
    Map<String, String> attributes = const {},
    this.replyToStreamId,
    this.attachedStreamIds = const [],
    this.version,
    this.generated = false,
    this.operationType,
  }) : super(
          id: id,
          mimeType: mimeType,
          topic: topic,
          timestamp: timestamp,
          size: size,
          attributes: attributes,
        );
}

abstract class StreamWriter<T> {
  Future<void> close();

  Future<void> write(T chunk);
}

typedef ByteStreamHandler = void Function(
    ByteStreamReader reader, String participantIdentity);

typedef TextStreamHandler = Function(
    TextStreamReader reader, String participantIdentity);
